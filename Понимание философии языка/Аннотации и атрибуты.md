## **1. Основные понятия**

### **Аннотации (`@...`)**

Управляют **безопасностью, оптимизациями и поведением компилятора**.
- Меняют семантику кода (например, отключают проверки).
- Нельзя создать через макросы (только системные).

### **Атрибуты (`#[...]`)**

Предоставляют **метаданные и подсказки** компилятору.
- Не влияют на семантику языка.
- Можно создавать пользовательские.

---

## **2. Стандартные аннотации**

### **Безопасность**

|Аннотация|Описание|Пример|
|---|---|---|
|`@safe`|Гарантирует отсутствие UB|`@safe fn read_file()`|
|`@basic`|Безопасность + ручное управление|`@basic fn parse()`|
|`@fast`|Оптимизации без UB|`@fast fn hash()`|
|`@raw`|Доступ к железу (ассемблер, MMIO)|`@raw fn read_port()`|
|`@unsafe`|Полный обход гарантий|`@unsafe fn ptr_to_int()`|
Атрибуты имеют четкую иерархию (сверху вниз).

### **Правила вызова**

```rust
graph LR
    A[@safe] --> B[@basic]
    B --> C[@fast]
    C --> D[@raw]
    D --> E[@unsafe]
```

- Функция может вызывать **только свой уровень или ниже**.
    
- Для вызова «опаснее» требуется **явный блок**

## **3. Стандартные атрибуты**

### **Оптимизации**

|Атрибут|Описание|Пример|
|---|---|---|
|`#[inline(always)]`|Принудительное встраивание|`#[inline] fn calc()`|
|`#[cold]`|Функция редко вызывается|`#[cold] fn error()`|
|`#[noreturn]`|Функция не возвращает управление|`#[noreturn] fn panic()`|

### **Метаданные**

| Атрибут         | Описание       | Пример                   |
| --------------- | -------------- | ------------------------ |
| `#[doc("...")]` | Документация   | `#[doc("Описание")]`     |
| `#[deprecated]` | Устаревший код | `#[deprecated] fn old()` |

---

## **4. Пользовательские атрибуты**

### **Создание**

```rust
// Объявление
#[attribute]
macro_rules! kernel {
    ($fn:item) => { ... }
}

// Использование
#[kernel]
fn gpu_compute() { ... }
```
### **Пространства имён**

```rust
#[my_crate::optimize(level = 3)] // Для избежания конфликтов
fn critical_code() { ... }
```

---

## **5. Пользовательские аннотации** _(через макросы)_

### **Пример: транзакции**

```rust
macro_rules! transactional {
    ($fn:item) => {
        @fast $fn // Разворачивается в @fast + добавляет логику
    }
}

transactional! { // Использование
    fn transfer() { ... }
}
```

### **Регистрация плагинами**

```rust
// Где-то в компиляторе:
register_annotation!("atomic", |ctx| {
    ctx.wrap_with_mutex(); // Автоматически добавляет блокировку
});
```

---

## **6. Сравнение с другими языками**

|Фича|Carbide|Rust|
|---|---|---|
|**Уровни безопасности**|`@safe`/`@raw`|`unsafe`|
|**Пользовательские аннотации**|✅ Да|❌ Нет|
|**Интеграция с компилятором**|Через макросы/плагины|Только proc-macro|

---

## **7. Примеры кода**

### **Смешанное использование**

```rust
@safe fn api_handler() {
    #[cache(ttl = "60s")] // Пользовательский атрибут
    let data = fetch_data();

    @fast {
        #[inline] // Стандартный атрибут
        let result = process(data);
    }
}
```

### **Низкоуровневый код**

```rust
@raw fn handle_interrupt() {
    #[interrupt] // Специальный атрибут для прерываний
    fn timer() {
        asm!("nop");
    }
}
```

---

## **8. Правила и лучшие практики**

1. **Аннотации** — для безопасности/оптимизаций, **атрибуты** — для метаданных.
    
2. **Документируйте** пользовательские аннотации:
```rust
/// # Аннотация @atomic
    /// Гарантирует потокобезопасность.
    register_annotation!("atomic", ...);
```
3. **Избегайте конфликтов**: квалифицируйте имена (`#[my_crate::foo]`).
    

---

## **9. Заключение**

Carbide предоставляет:

- **Гибкую систему аннотаций** для контроля над кодом.
- **Расширяемые атрибуты** для метапрограммирования.
- **Чёткое разделение** между безопасностью и оптимизациями.
    
Это делает язык **мощным для системного ПО** и **удобным для высокоуровневых задач**.