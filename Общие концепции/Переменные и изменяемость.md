
## **1. Объявление переменных**

### **`let` — неизменяемая переменная**

- **Лексическая область видимости** (как в Rust).
- **Значение нельзя изменить** после инициализации.

```rust
@safe fn main() {
    let x = 10; 
    // x = 20; // Ошибка: `x` неизменяема
}
```

---

### **`let mut` — изменяемая переменная**

- Позволяет изменять значение.
- Проверка на уровне компилятора:

```rust
@safe fn main() {
    let mut y = 20;
    y += 5; // OK
}
```

**Ограничения в `@safe`:**

- Нет неинициализированных переменных.
- Нет доступа к `mut` через сырые указатели.

---

## **2. Константы**

### **`const` — константа времени компиляции**

- **Вычисляется при компиляции**.
- **Не имеет адреса в памяти** (подставляется как литерал).
- Должна быть инициализирована константным выражением.

```rust
const PI: f64 = 3.141592653589793;
const MAX_SIZE: usize = 1024 * 1024;
```

**Где можно использовать:**

- Размеры массивов (`let arr: [u8; MAX_SIZE]`).
- Условия в `match` и `if`.

---

### **`constexpr` — строгая константа времени компиляции**

- **Запрещает runtime-вычисления** даже в `@safe`.
- Требует чистых функций и литералов.

```rust
constexpr fn factorial(n: u32) -> u32 {
    if n == 0 { 1 } else { n * factorial(n - 1) }
    const FACT_5: u32 = factorial(5); // 120
}
```

**Отличия от `const`:**

|`const`|`constexpr`|
|---|---|
|Может использовать runtime-логику|Только compile-time|
|Допускает вызовы `@safe`-функций|Только `constexpr`-функции|

---

## **3. Статические переменные**

### **`static` — глобальная переменная**

- **Существует всё время работы программы**.
- **Доступна из любого места** (с учётом видимости модуля).

```rust
static APP_NAME: &str = "Carbide";
static mut COUNTER: u32 = 0; // Требует unsafe для изменения
```

**Ограничения:**

- `static` без `mut` — потокобезопасна (аналогично `const` + адрес в памяти).
- `static mut` — требует `@unsafe` для изменения.

---

### **`static mut` — изменяемая глобальная переменная**

- **Только в `@unsafe`-блоках** для изменений.

```rust
@unsafe fn increment() {
    static mut COUNT: u32 = 0;
    COUNT += 1; // OK
}

@safe fn read() -> u32 {
    unsafe { COUNT } // Чтение требует unsafe (!)
}
```

**Альтернатива для `@safe`:**  
Используйте `Atomic` или `Mutex`:

```rust
use std::sync::atomic::AtomicU32;

static COUNT: AtomicU32 = AtomicU32::new(0);

@safe fn increment() {
    COUNT.fetch_add(1, Ordering::SeqCst);
}
```

---

## **4. Сравнение типов переменных**

|Ключевое слово|Изменяемость|Время жизни|Область видимости|Требует `unsafe`?|
|---|---|---|---|---|
|`let`|Нет|Лексическая|Блок|Нет|
|`let mut`|Да|Лексическая|Блок|Нет|
|`const`|Нет|Компиляция|Глобальная|Нет|
|`constexpr`|Нет|Компиляция|Глобальная|Нет|
|`static`|Нет|Вся программа|Глобальная|Нет|
|`static mut`|Да|Вся программа|Глобальная|Да (`@unsafe`)|

---

## **5. Особые случаи**

### **Деструктуризация**

```rust
let (a, b) = (1, 2);
let Point { x, y } = Point::new(3.0, 4.0);
```

### **Тип можно не указывать**

```rust
let x = 10;   // i32
let y = 3.14; // f64
```

---

## **6. Примеры для разных аннотаций**

### **`@safe` (максимальные ограничения)**

```rust
@safe fn example() {
    let x = 10; // Неизменяемая
    let mut y = 20; // Изменяемая
    const MAX: usize = 100; // Константа
    // static mut Z: u32 = 0; // Запрещено в @safe
}
```
### **`@raw` (ручное управление)**

```rust
@raw fn hardware() {
    static mut PORT: *mut u32 = 0xFEED as _;
    @unsafe { *PORT = 42; } // Прямая запись в память
}
```

### **`@unsafe` (полный доступ)**

```rust
@unsafe fn danger() {
    static mut GLOBAL: u32 = 0;
    GLOBAL += 1; // Можно без блока
}
```

---

## **7. Итоговые правила**

1. **По умолчанию** — `let` (неизменяемый) и `const`.
2. **Для изменяемости** — `let mut` (локально) или `static mut` (глобально, с `@unsafe`).
3. **Для констант** — `const` (гибкость) или `constexpr` (строгий compile-time).
4. **Глобальные данные** — `static` (без `mut`) или атомарные типы.

```rust
// Идеология Carbide:
@safe fn main() {
    const VERSION: &str = "1.0"; // Константа
    let mut counter = 0;         // Изменяемая переменная
    increment(&mut counter);     // Передача mutable ссылки
}

fn increment(x: &mut u32) {
    *x += 1;
}
```

Это сочетает **безопасность Rust** с **гибкостью C** для системного программирования.