
## **Введение**
Carbide — язык с явной строгой статической типизацией. Типы проверяются на этапе компиляции.

### **Скалярные типы**
Скалярный тип представляет одно значение. Carbide имеет четыре основных скалярных типа: целые числа, числа с плавающей точкой, логические значения и символы. Вы можете узнать их из других языков программирования.

### **Целочисленные типы**
Целое _число_ — это число без дробной части.

| Длина                | Со знаком | Без знака |
| -------------------- | --------- | --------- |
| 8-битный             | `i8`      | `u8`      |
| 16-битный            | `i16`     | `u16`     |
| 32-битный            | `i32`     | `u32`     |
| 64-битный            | `i64`     | `u64`     |
| 128-битный           | `i128`    | `u128`    |
| Зависит от платформы | `isize`   | `usize`   |

| Числовые литералы  | Пример        |
| ------------------ | ------------- |
| Десятичная дробь   | `98_222`      |
| Шестнадцатеричный  | `0xff`        |
| Восьмеричный       | `0o77`        |
| Двоичный           | `0b1111_0000` |
| Байт ( `u8`только) | `b'A'`        |

### **Числа с плавающей точкой**

Тип по умолчанию: f64
Предупреждение: IEEE 754 (`0.1 + 0.2 != 0.3`)

| Длина     | Тип |
| --------- | --- |
| 32-битный | f32 |
| 64-битный | f64 |

### **Числовые операции**

| Действие           | Оператор |
| ------------------ | -------- |
| Сложение           | +        |
| Вычитание          | -        |
| Умножение          | *        |
| Деление            | /        |
| Остаток от деления | %        |

### **Булев тип**
Тип: bool.
Значения: true, false.
(Не преобразуется неявно в целочисленный тип, как в С)

### **Символьный тип**
Тип: char.
Хранить в одинарных кавычках. Занимает 4 байта: символ Unicode.
Хранит символы Unicode, что позволяет работать с эмодзи и буквами любых языков.

## **Составные типы данных**
_Составные типы_ могут группировать несколько значений в один тип. Carbide имеет два примитивных составных типа: кортежи и массивы.

### **Массивы**
Массив - коллекция, состоящая из нескольких элементов ***одного*** типа. Хранится на стеке. (см. [[Память]])
``` rust
fn main() {
    let array = [1, 2, 3, 4, 5];
}
```


#### **Инициализация одним значением**
```rust
let array = [0; 5]; // [0, 0, 0, 0, 0]
```

#### **Доступ к элементам массива***
Массив имеет возможность обращаться к элементу массива по индексу. Пример:
```rust
fn main() {
    let array = [1, 2, 3, 4, 5];
    print!("{array[0]}");
}
```
В качестве аргумента оператор ***[]*** принимает число типа ***usize***, поэтому нужно явно преобразовывать числа других типов к usize с помощью оператора ***as***, иначе будет ошибка компиляции:
```rust
fn main() {
    let array = [1, 2, 3, 4, 5];
    let index: u32 = 3;
    print!("{array[index as u32]}");
}
```
Также этот подход убирает возможность ввода в оператор отрицательного значения.

#### **Неверный доступ к элементу массива***
Если index >= array.length(), то в зависимости от аннотации (см. [[Аннотации и атрибуты]]) Будет разное поведение. Рассмотрим код ниже:

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    print!("{array[7]}");
}
```
Видно, что происходит выход за пределы длины массива. Зависимость от аннотации:
- @basic и выше: будет вызван panic! с сообщением `index out of bounds`. (см. [[Обработка ошибок]])
- @fast и ниже: будет UB. (см. [[Особые языковые ситуации]])

В случае, если мы не уверены в корректности нашего индекса, но мы можем:
- Проверить корректность индекса вручную (см. [[Управление потоком]]):
```rust
fn main() {
    let array = [1, 2, 3, 4, 5];
    let index: usize = 7;
    print!("{index < array.length() ? array[index] : 0}");
}
```
- Использовать метод ***get*** или ***get & unwrap_or (unwrap_or_else)*** (см. [[ООП]] и [[Обработка ошибок]]):
```rust
fn main() {
    let array = [1, 2, 3, 4, 5];
    let element = array.get(7).unwrap_or(-1);
    print!("{array[index as u32]}");
}
```

### **Кортеж**
Кортеж - коллекция, состоящая из нескольких элементов ***разных*** типов. Хранится на стеке. (см. [[Память]])
```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

### **Деструктуризация**
```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, z) = tup; // Доступ к элементам через паттерн
}
```

#### **Обращение к элементу кортежа**
Индексация через `.0`, `.1` и т.д.
За счет того, что кортеж гетерогенен, по нему нет возможности итерировать, вследствие чего проверки на валидность обращения по индексу происходят на этапе компиляции, что спасает нас от panic!, UB, get и т.п.
```rust
fn main() {
    let tup = (500, 6.4, 1);
    print!("{tup.5}"); // compile-time error
}
```

### **Сравнение массивов с кортежами**
Кортежи полезны для возврата нескольких значений из функций, тогда как массивы — для однотипных коллекций.